# @file calculate_average_coverage.py
# This script will return the average coverage of the target region.
# It expects two inputs:
# -b/--bedfile  A BED file containing the targeted regions (e.g. probes)
# -i/--input    The coverage output generated by BEDtools genomecov, e.g.
#               bedtools genomecov -split -dz -ibam input_file.bam -g genome.fasta > genomecov.txt
# 
# The script also REQUIRES that the 'bedtools' executable be in the 
# $PATH for shell/subprocess calls to it.

import os
import numpy
import argparse
import numpy
import subprocess

"""
Returns the number of unique bases covered in the input
BED file's regions. Overlaps only get counted once.
"""
def get_bed_base_count(filepath):
    command = ('bedtools sort -i {filepath} '.format(filepath=filepath) +
        '| bedtools merge ' + 
        '| awk \'{for(i=$2;i<$3;i++) print $1"\t"i}\' ' +
        '| sort | uniq | wc -l')
    proc = subprocess.Popen([command], stdout=subprocess.PIPE, shell=True)
    resp = proc.communicate()[0].strip()
    return int(resp)
    # end get_bed_base_count()

"""
Converts the genomecov output into a BED format that can then be 
filtered/processed as normal using bedtools.
"""
def genomecov_to_bed(input_filepath, output_filepath):
    fileout = open(output_filepath, 'w')
    with open(input_filepath, 'Ur') as filein:
        for line in filein:
            line = line.strip()
            if len(line):
                line = line.split('\t')
                lineout = [
                    line[0],
                    int(line[1]) - 1,
                    line[1],
                    line[2],
                    '+',
                    line[2],
                ]
                if lineout[1] < 0:
                    lineout[1] = 0
                lineout = '\t'.join([str(x) for x in lineout])
                fileout.write('{0}\n'.format(lineout))
        filein.close()
    fileout.close()
    # end genomecov_to_bed()

"""
Acts as a wrapper around bedtools intersect commands.
"""
def intersect_bed(inputA, inputB, output):
    command = 'bedtools intersect -a {fileA} -b {fileB} > {output}'.format(
        fileA=inputA,
        fileB=inputB,
        output=output,
        )
    resp = subprocess.Popen([command], stdout=subprocess.PIPE, shell=True).communicate()[0]
    # end intersect_bed()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('-i', '--input', dest='input', type=str,
        help='Input (coverage data) filepath.')
    parser.add_argument('-b', '--bedfile', dest='bedfile', type=str,
        help='Target regions BED file.')
    parser.add_argument('-o', '--output', dest='output', type=str,
        help='Output filepath.')

    args = parser.parse_args()

    if args.input is None:
        print('Error: Input file must be specified!')
        exit()
    else:
        input_filepath = os.path.abspath(args.input)
        if not os.path.isfile(input_filepath):
            print('Error: {0} does not exist!'.format(input_filepath))
            exit()

    if args.bedfile is None:
        print('Error: BED file must be specified!')
        exit()
    else:
        bedfile_filepath = os.path.abspath(args.bedfile)
        if not os.path.isfile(bedfile_filepath):
            print('Error: {0} does not exist!'.format(bedfile_filepath))
            exit()                


    if args.output is None:
        print('Error: Output file must be specified!')
        exit()
    else:
        output_filepath = os.path.abspath(args.output)


    # Get the count of targeted bases so the average can be adjusted
    # accordingly in case not every base was covered.
    in_target_bases = get_bed_base_count(bedfile_filepath)

    # Filter the genomecov output to get only in-target values.
    coverage_bedfile = input_filepath + '.bed'
    genomecov_to_bed(input_filepath, coverage_bedfile)
    in_target_coverage = input_filepath + '.in_target'
    intersect_bed(coverage_bedfile, bedfile_filepath, in_target_coverage)

    values = []
    bases = 0
    with open(in_target_coverage, 'Ur') as filein:
        for line in filein:
            if len(line):
                line = line.split('\t')
                values.append(int(float(line[3])))
                bases += 1
        filein.close()

    # If any bases weren't coverered, add the zero-coverage values to
    # get the correct per-base coverage value.
    if bases < in_target_bases:
        values += [0] * (in_target_bases - bases)

    # Write out the output
    fileout = open(output_filepath, 'w')
    average = int(numpy.mean(values))
    fileout.write('{0}\n'.format(average))
    fileout.close()

    # Delete intermediate files
    os.remove(coverage_bedfile)
    os.remove(in_target_coverage)
